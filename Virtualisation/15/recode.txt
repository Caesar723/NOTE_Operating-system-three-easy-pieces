15.0
为了实现高效虚拟化，操作系统尽量让程序自己运行
在关键点时介入interposing，保持对硬件控制
问：
	如何高效实现内存虚拟化
	如何提供内存所需的灵活性-程序以任何方式访问自己的地址空间
	保持控制应用程序可访问的内存位置-只能访问自己的内存空间

硬件地址转换 hardware-based address translation（地址转换address translation，受限直接运行的补充）
	硬件对每次内存访问都会处理（如指令获取，数据获取，写入）
	将虚拟地址virtual 转换成物理地址physical

只靠硬件时不够的
操作系统要在关键时刻介入 interposing，设置硬件
操作系统必须管理内存manage memory
记录占用和空闲的内存位置

15.2
对于程序来说，address space 是从0开始16kb结束
对于虚拟内存来说，操作系统希望把address space放到物理内存的其他位置而不是从0开始

15.3
动态重定位dynamic relocation
	每个CPU需要两个硬件寄存器：基址base 寄存器和界限bound寄存器--（限制寄存器limit）
	这些寄存器可以将address放 space在物理内存的任何位置
	同时保证进程只会访问自己的address space
	base将虚拟地址转为物理地址
	bound确保进程地址在空间范围内	-比如bound设置了16kb，地址找过16就会发生异常
	physical address=virtual address+base
	（这种重定位是在运行时发生的，我们可以在运行后改变其地址空间- dynamic relocation）

	因为两个寄存器在CPU里，这个CPU负责的地址转换叫Memory management unit （MMU）


free list-记录没有使用的物理内存范围

15.4
硬件支持：总结
	硬件要求				解释
	----------------------------------------------------------------------------
	特权模式				防止user mode的进程执行特权操作
	base bound寄存器			每个CPU需要一堆寄存器来地址转换和界限检查
	能转换地址并检查是否越界		用电路完成，这样会非常简单
	修改base bound寄存器特权指令		在用户程序运行前，操作系统可以修改这些值
	注册异常处理程序的特权指令		操作程序要告诉硬件，如果有异常，就执行哪些代码
	能触发异常				如果进程用特权指令或越界内存
	-----------------------------------------------------------------------------
	
	我们要两种CPU模式- kernel mode和user mode
	只要一bit ，保存在process status mode中，就可以说明CPU的运行模式
	每个CPU内存管理单元MMU 需要两个寄存器-base register \bound register
	程序运行时，硬件会转换地址并检查地址是否有用
	硬件会提供一些特殊指令（特权privileged 指令）来修改这两个寄存器，运行操作系统在切换进程时改变它们
	用户程序在尝试非法访问内存时，CPU能产生异常exception
	CPU会阻止程序运行，安排系统的exception handler去处理
	exception handler会做出正确的回应

15.5
操作系统要求			解释
------------------------------------------------------------------------------------
内存管理				为新进程分配内存
				从终止的进程回收内存
				通过free list来管理内存

base bound 管理			在contact switch时正确设置base\ bound寄存器

异常处理				当发生异常的时候执行的代码
---------------------------------------------------------------------------------------

在进程创建时：
	操作系统为进程的地址空间找到内存空间
	操作系统会搜索free list找到位置并将其标记为已用
当进程终止时：
	操作系统会将此进程的内存放回空闲列表
	根据需要清除相关数据结构

	操作系统可以改变其他地址空间的物理地址
	操作系统会让一个进程停止
	将地址空间拷贝到新的位置
	更新保存base register，指向新位置
上下文切换时：
	操作系统要保存和恢复base 和bound register
	当操作系统终止当前进程运行时
	会将base和bound register的内存保存在内存中，放在每个进程都有的结构中（进程结构process structure，进程控制块process control block PCB）
	当恢复进程时，要设置正确的值

操作系统要提供异常处理程序exception handler
	操作系统会在启动时通过特权命令加载这些程序
	
****************************************************************************************
受限直接访问（动态重定位）

操作系统启动：
	（kernel mode）初始化陷阱表
			｜
			V
	（硬件）记住地址：
		系统调用处理程序
		时钟处理程序
		非法内存处理程序
		非常规指令处理程序
			｜
			V
	（kernel mode）开始中断时钟
			｜
			V
	（硬件）开始时钟，在xms时中断
			｜
			V
	（kernel mode）初始化进程表，初始化free list
	
程序系统运行：
	（kernel mode）启动进程A
			在进程表中分配条目
			为进程分配内存
			设置base\bound register
 			从陷阱返回，进入A
			｜
			V
	（硬件）恢复A的寄存器，转向user mode，跳到A的程序计数器
			｜
			V
	（user mode）运行进程A，获取指令
			｜
			V
	（硬件）转换虚拟地址并获取
			｜
			V
	（user mode）执行指令
			｜
			V
	（硬件）如果要显示加载或保存
		确保地址不越界
		转换虚拟地址并执行
		加载\保存
			｜（直到时间中断）
			V
	（硬件）时间中断，转向kernel mode，调到中断处理程序
			｜
			V
	（kernel mode）处理陷阱，调用switch（）例程切换上下文
			将寄存器A保存到进程结构A
			将进程结构B恢复到寄存器B（都包括base\bound register）
			从陷阱返回
			｜
			V
	(硬件)恢复B寄存器，转向user mode，调到B的程序计数器
			｜
			V
	（user mode）运行B，执行错误加载
			｜
			V
	（硬件）加载越界，转向kernel mode ，调到陷阱处理程序
			｜
			V
	（kernel mode）决定终止进程B，回收B的内存，移除B在进程表中的条目

			
15.6
在address space里由于栈区和堆区用到的不多，但使用的物理内存都大，就会有浪费（内部碎片internal fragmentation）
