21.0
目前都是假设address space能放入内存
现在我们要支持同时运行巨大的地址空间
目前我们都假设内存的页都是常驻在物理内存中
现在要支持更大的address space
操作系统需要把当前没有在用的那部分地址空间找个地方（要不内存大）储存起来
硬盘hard dick drive和SSD闪存 可以满足这个需求
操作系统可以透明的提供虚拟地址空间假象

21.1
交换空间swap space
	开辟一部分空间用于移入和移出
	将内存的页交换到其中
	在需要的时候交换回去
操作系统需要记住给定页的磁盘地址disk address

假设有4页物理内存和8页交换空间和3个进程
	3个进程主动共享物理空间
	3个进程每一个都有一部分有效页在内存中
	剩下的在磁盘的交换空间中
	第4个进程所有的页在交换空间中（这个没有运行）

如果运行一个二进制程序（自己的main程序或ls）
	代码页最开始在磁盘上
	程序运行时会一页一页加载到内存中（现在的方法）
21.2 
假设有一个硬件管理TLB的系统
如果希望页交换到磁盘，要在原基础上加更多机制
当硬件在PTE查找时，可能发现页不在内存中
这个用新信息来显示-存在位present bit（1为在物理内存中，0在硬盘上）
访问不在物理内存的页，叫页错误page fault

21.3
页错误page fault
几乎所有的系统都在软件中处理page fault
问题：
	操作系统如何知道所需的页在盘底哪里（可以用PTE的某些位来存地址，项PFN）
当操作系统受到错误时，会在PTE找地址，将请求发送到硬盘，将页读取到内存中
当硬盘IO完成时
操作系统会更新页表，将present bit改成1
更新PTE的PFN来记录新获取页的内存位置
然后再次访问
TLB会说未命中（这次时因为没有更新在TLB中）

21.4
如果内存满了
操作系统可以系统换出page out一个或多个页
页交换策略page- replacement policy
	选择哪些页来替换replace

21.5
页错误处理流程
	首先操作系统会先去找free的物理帧FPN
	如果没有FPN（内存满了）
	会调用页交换算法得到一个空的FPN（算法会先检查是否有空闲页，如果没有，通知swap daemon按需要释放页）
	之后要等待IO（从交换空间读取页）
	之后把PTE的present bit设为1
	把PTE的PFN设为现在的FPN
	然后重新在试一下指令（访问数据）

21.6
目前为止是只有等到内存满了才会执行replacement的流程（不切实际）
	操作系统可以主动预留一些空闲空间
操作系统会设置高水位线high water mark和低水位线low watermark
	当操作系统发现有少于LW的页可以用时，后台会让释放内存的线程运行，直到到了HW个可用的物理页
	后台线程有时叫交换守护线程swap daemon（守护进程 page daemon）
	