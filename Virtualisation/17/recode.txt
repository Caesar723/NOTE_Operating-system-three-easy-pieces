17.0
空闲空间管理free-space management
管理的空闲空间由不同大小组成，会变得困难，因为外部碎片external fragmentation
	出现在用户级的内存分配库（malloc（），free（））
	或操作系统用分段segmentation方法实现虚拟内存
17.1
在堆上管理空闲空间的数据结构为free list（包含了管理内存区域中所有空闲块的引用，该数据结构是一个可以追踪空闲空间的数据结构）
	
一个程序调用malloc（），获得一个指向一块空间的指针，这块区域就属于这个程序了
库不可以移动，直到程序调用free（），所以不可以紧凑compaction来减少碎片

但操作系统实现分段segmentation就可以实现紧凑compaction

17.2
分割与合并
free list：
	head->add:0,len:10->add:20,len:10->NULL
任何大于10字节的分配请求会失效-没有足够的可连续空间（return NULL）

如果只申请1字节的空间：
	分配程序会执行分割splitting
	会找到可以满足请求的空间，将其分割
	第一块会返回给用户
	第二块留在空闲列表中
	head->add:0,len:10->add:21,len:9->NULL

合并coalescing：
	head->add:10,len:10->add:0,len:10->add:20,len:10->NULL
	如果用户请求20字节的空间，会返回失败，因为没有足够的可连续空间
	为了避免这个问题，程序会在释放内存时并合并可用的空间
		在还一块内存块时
		会查看内存块地址和相邻的空间块
		如果有相邻，就将它合成较大的空间块
	head->add:0,len:30->NULL


追踪已分配空间的大小
	大部分分配程序会在header中保存一点额外的信息，它在内存中，通常放在内存块之前
	此header包含了一些格外指针加速空间释放
	如果用户请求N字节，库不会寻找大小N的空间块，而是寻找N+header块大小的空间块

嵌入空闲列表
	如何在空闲内存内部建立一个列表
	freelist.c
	这个list记录的大小为4080
	假设有一个100字节的内存请求
	库会找到4080的块然后分割split
	一块满足请求，一块是剩余空闲块
	假设记录头块header是8字节，那么剩余的是3972（库分配了108字节）
	
	如果要free（）一个空间，小空间块的next指针会指向大空间块的地址
	如果不用合并coalesce，没个空闲块的next指针会指向另一个，这会变得很糟
	解决：
		遍历列表，合并merge相邻块

让堆增长：
	sbrk系统调用
	会找到空闲的物理内存页
	将他们映射到请求进程的address space里
	返回堆堆末尾地址

17.3
管理空闲空间的基本策略

最优匹配best fit
	遍历整个空闲列表
	找到大于等于请求大小的空闲块
	返回其中最小的一块
	（遍历要付出高的性能代价）

最差匹配worest fit
	尝试找最大的空闲块
	split之后把剩余的放入free list
	（遍历，过量的碎片，很高的开销）

首次匹配first fit
	找到一个足够大的块，剩余空间留给后续请求
	不需要遍历所有空闲块
	（有时会让空闲列表开头有很多小块）

下次匹配next fit
	多一个指针
	指向上次查找结束的位置
	避免对列表开头频繁split


17.4
其他方式

分离空间列表segregated list
	如果某个程序进程申请一种或几种大小的内存
	用一个独立的列表来管理这样大小的的对象
	其他大小的交给更通用的分配程序
	
二分伙伴分配程序binary buddy allocator
	让合并变得简单
	空闲空间首先会被看成2^N大小
	当有内存分配时，空闲空间会被递归的一分二（一直除以2）
	如果一个8kb空间被释放
	程序会检查另一个伙伴（8kb）是否时空闲空间
	如果是就可以合并成16kb，然后再检查伙伴（16kb）。。。

查找列表会很慢，缺乏可扩展性scaling
别的算法：
	牺牲简单性来换取性能
	平衡二叉树，伸展树，偏序树
	
	

