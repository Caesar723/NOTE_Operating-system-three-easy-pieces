14.1
内存类型
栈内存：
	申请和释放是编译器隐式管理的
	也被称为自动automatic 内存
	在C中申请栈内存：在函数中为一个变量申请空间
·	编译器会在你进入函数的时候，在栈上开辟空间
	在退出函数的时候，编译器会释放内存

堆heap内存：
	所有的申请和释放都由程序员显示地完成
	int *x=(int *)malloc(sizeof(int));
	编译器看到int * 知道为整数指针分配空间
	当程序调用malloc会在堆上请求整数空间

14.2
malloc()
需要size_t类型参数
返回的是一个void类型指针，让程序员去处理-通过强制转换cast

14.3
free（）
知道何时，如何释放内存是困难的
接受一个malloc（）函数返回的指针

14.4
常见错误
许多语言都支持内存管理automatic memory management
当你调用类似malloc像new时
不需要调用某些东西来释放内存
因为有垃圾收集器garbage collector-找出你不再引用的值，替你释放它

忘记分配内存
	在用strcpy（）时
	将原字符串复制到指针目标会出现

没有分配足够内存
	缓冲区溢出buffer overflow
	运行会正常运行
	在某些情况下，当字符串拷贝时
	会在超过分配空间的尾处写入一个字节
	某些情况下是无害的，但有时会有很大的危害
	malloc总是会分配一些额外的空间
	这样不会在其他变量上涂写

忘记初始化内存分配：
	当你正确调用malloc
	但忘记初始化了
	程序会遇到未初始化读取 uninitialized read
	它会从堆中读取一些未知数据

忘记释放内存
	内存泄露memory leak
	如果忘记释放内存，在长时间运行的程序来说会有错误
	缓慢泄露内存会导致内存不足
	
	如果进程运行时间短，很快就会退出，不用free也是可以的
	操作系统会清理其分配的所有的页面
	但这是一个环习惯

在用完之前提前释放内存
	错误称为悬挂指帧dangling pointer
	调用了free但又再次调用malloc来分配其他内容

反复释放内存double free
	有可能会导致崩溃

错误调用free（）
	free只希望你传入malloc得到的指针
	如果传入别的值，坏事会发生
	无效释放invalid free

14.6 
calloc 避免忘记初始化
realloc 用于添加一些东西时
