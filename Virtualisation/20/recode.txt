20.0
系统中，每个进程都有一个页表page table
32位地址空间
4KB的页和4字节的页表项，一个进程有一百万个虚拟页面
如果有一百个进程
就要为内存分配数百兆的内存
问题：
	如何让页表page table更小

20.1
更大的页
但会导致内存浪费，内部碎片internal fragmentation

20.2
结合分页和分段
杂合hybrid

不是为每个address space提供一个page table
而是为每一个段（代码段，堆，栈段）提供一个page table
基址寄存器base 
	保存该段页表的物理地址
界限bound寄存器
	指示页表的结尾

系统中每个进程都有3个与其关联的页表
在上下文切换时，要更改这些寄存器
分段位SN（00为未使用段，01为代码段，10为堆，11位栈）

在TLB未命中时：
	硬件会用SN确定时是哪个base bound对
	然后将物理地址和VPN结合起来，形成PTE

问题：
	页表会变成任意大小
	为他们寻找自由空间会很麻烦

20.3
多级页表multi-level page table
去掉页表中无效的区域

将页表分成页大小的单元
如果这个页单元的整个页表项PTE无效，就完全不分配该页的页表
这个只是让线性页表的一部分消失
页目录page directory	
	追踪页表的页项PTE是否有效
	会告诉你页表的页在哪里
	页目录的每一项叫页目录项 page directory entries
	如果一个PDE的valid是1
	那他所对应的那个页单元里至少有一个PTE是有效的

问题：
	当TLB未命中时
	可能需要从内存加载两次才可以命中
	（一次为页目录，一次为PTE页表项本身）
	比简单的线性页表复杂


20.4
反向页表
inverted page table

20.5
将页表交换到磁盘
页表仍然有可能太大而无法一次装入内存
一些系统把这样的页表放入 内核虚拟内存kernel virtual memory
在内存压力太大时
将页表中的一部分交换到swap到磁盘	