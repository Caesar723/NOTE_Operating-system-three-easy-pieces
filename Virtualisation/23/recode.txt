23.1
VMS系统
主要架构师是Dave Cutler（后来开发Windows nt）
VMS是软件创新很好的例子
用于隐藏架构的一些固有的缺陷

23.2
VAX-11
	为每个进程提供32位虚拟地址空间
	每页为512字节
	所以虚拟地址为23位VPN
	9位offset
	由于此系统是分页和分段混合体
	VPN前两位是用来显示段的

	地址空间的下半部分是进程空间
	进程空间的一部分p0有用户程序和堆
	p1是栈
	地址空间上半部分是系统空间（s）
	存操作系统的代码和数据
	用于跨进程共享

	VMS的页大小非常小
	所以首要目标是确保VMS不会用页表占满内存
	
	所有这个系统会为每个进程的每个区域（p0，p1）都提供页表
	所以堆栈未使用的空间不会放入表内

	内核的虚拟内存中会存放这些表
	在分配或增长表时
	内核在S段分配自己的内存空间

23.3
真实的地址空间

	int *p=NULL;
	*p=10;//硬件在TLB 找VPN miss hit并发现VPN0 被标记为无效，会报错
	代码段永远不会在第0页开始（该页标记为不可访问，为检测空指针null pointer提供支持）

	内核虚拟地址空间是每个地址空间的一部分	
	在上下文切换时操作系统会改变p0 p1指向即将运行的进程的页表
	但不会改变S的base bound register
	
	内核映射到每个地址空间的原因：
		如果操作系统收到用户提交的指针
		很容易将数据复制到它自己的结构

	操作系统不希望用户程序可以读取或写入操作系统的数据和代码
	因此操作系统要支持页面的不同保护级别才可以用该功能
	系统的数据和代码会被设置成比用户的更高的保护级别

23.4
分段FIFO
	每个进程都有一个可以保存在内存中的最大页数 驻留集大小Resident set size RSS
		当一个进程的页超过RSS
		先入的页会被踢出
	二次机会列表second-chance list
		页在被踢出前会放入其中
		如当进程P超过RSS时
		会将每个进程FIFO中移除一个页
		干净页会放在全局干净列表的尾部
		脏页会放在全局脏列表的尾部
	如果进程P遇到页错误
	就可以在这两个列表中找回自己的页（这样就避免了磁盘IO）
	如果进程Q需要空闲页
	就在干净列表里抽出第一个页

页聚集（clustering）
	磁盘在大小传输中效果更好	
	VMS会将全局脏列表的页聚集在一起
	然后一举写入磁盘

23.5
写时复制copy on write
	操作系统需要将一个页面从一个地址空间复制到另一个地址空间
	可以将其映射带地址空间而不是复制
	然后在两个地址空间标记为只读
	这样可以提升速度
	如果一个地址空间想写入页面
	就会陷入操作系统
	会分配一个新页，填充数据
	将这个新页映射到要写入的那个地址空间
	
	
	