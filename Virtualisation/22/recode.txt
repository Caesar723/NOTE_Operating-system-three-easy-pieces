22.0
替换策略replacement policy
	决定在内存压力memory pressure 大的时候把哪一页换出paging out

22.1
可以把虚拟内存页视为缓存cache
目标是让缓存未命中cache miss最少（使磁盘取页的次数最少）
让cache hit最多

平均内存访问时间average memory access time	
	衡量硬件缓存的指标
	AMAT=[缓存命中的概率（Phit）*访问内存的成本（Tm)] + [缓存未命中的概率（Pmiss）*访问磁盘的成本（Td）]
	Phit+Pmiss=1

	设有9个虚拟页在内存，1个页在磁盘
	那就是9个hit（90%） 1个miss（10%）
	设访问内存的成本是100ns
	访问磁盘是10ms
	AMAT=0.9*100ns + 0.1*10ms =90ns+1ms=1ms

	如果命中率是99.9%
	那AMAT是10.1us快100倍
尽可能避免未命中

22.2
最优optimal替换策略（很难实现）
假设访问的页为0 1 2 0 1 3 0 3 1 2 1
在刚开始0 1 2 会未命中，因为缓存开始是空的（冷却未命中cold-start miss）
当到3时缓存满了，用最优策略进行替换
	检查0 1 2 未来的访问情况
	发现2是在很久以后才会被访问
	把2踢出

22.3｜22.4
FIFO 和 random

22.5
FIFO 和 random都有可能会提出重要的页（马上会被引用）

频率frequency
	如果一个页被访问多次，那不应该替换
近期性recency
	近期访问的页，在此访问的几率更大
这些倾向于向循环和数组之类的


最不经常用策略least- frequently-used（LFU）

最少最近用least- recently-used（LRU）
	每次访问时
	我刚刚访问的放在第一位
	别的页将一位
	当要替换时，把最后一位的替换掉
	在循环时表现不好
22.8
实现完美LRU代价比较大
所以用近似LRU
	在硬件上面加一个使用位use bit
	每当页被读和写时use bit会变成1
	但硬件不会把它变成0
	这个有操作系统负责

	时钟指针clock hand会指向一个最不需要的页
	当必须进行页替换时
	操作系统会检查当前指向的页是1还是0
	如果是1就说明最近用过
	然后该页的use bit会变成0
	指针会指向下一页
	会一直持续这样的操作直到有0的页出现，将其踢出
	（如果所有页都是一，那就将所有页都变成0）

22.9
考虑脏页
如果这个页已经被修改modified 那它就会变脏dirty
踢出这个页就必须写入磁盘
但干净clean的页（没有修改的）被踢出
就不需要额外的IO
所以时间算法可以修改一下	
	先把未使用，又干净的页先踢出
	无法找到这种页的话，再找脏的未使用页

22.10
替换页面不是唯一的策略

页选择策略page selection
	操作系统要决定何时将页载入内存

预取prefetching
	假设如果代码页p载入内存
	代码页p+1也可能载入

如何决定将页面写入磁盘
	聚集写入clustering-一次写入大的
	一次写入大的比一次写入小的要快

22.11
抖动thrashing
	正在运行的进程的内存需求超出了可用的物理内存
	系统就会不断换页

目前一些系统会采用严格的方式解决内存过载
	有些linux会运行 内存不足杀手程序out-of- memory killer
	会选择内存密集型进程并杀死它
	问题：
		如果杀死了某服务器
		会导致某些程序不可用	
