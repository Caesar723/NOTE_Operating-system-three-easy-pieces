6.0 
构建虚拟化机制的挑战
	性能 不增加系统开销
	控制权 运行进程同时保留对cpu的控制-如果没有权限，一个进程可不限制地运行并接管机器或访问没有权限的消息

直接运行	direct execution
	在进程列表上创建条目
	为进程分配内存
	将程序加载到内存中
	根据argc argv初始化栈

	清除寄存器
	执行main（）方法直到执行return

	释放进程的内存并存进程列表中删除

受限的直接运行 limited direct execution

6.2
用户模式 user mode
	在用户漠视下，系统无法发出io请求
内核模式 kernel mode
	运行代码可以做它喜欢做的事

如果希望用户执行某种特权操作
	用户程序执行系统调用-允许内核小心地向用户程序暴露某些关键功能（访问文件系统，创建销毁进程，与别的进程通信）

执行系统调用
	执行特殊的 陷阱trap指令-该指令同时跳入内核并将权限级别调到内核模式
	执行完成后，会调用 陷阱返回 return from trap 指令- 会返回到调用程序中并将权限下降到用户模式
	c中系统调用是用汇编编写的

受限直接运行协议LDE协议：
  机器启动时
	初始化陷阱表（内核模式）-> 硬件记住系统调用程序的地址（硬件)
  
  开始一个进程
	（内核模式）
	在进程列表上创建条目
	为程序分配内存
	将程序加载到内存中根据argv设置程序栈
	用寄存器和PC填充栈
	从陷阱trap返回
	     ｜
	     V
	（硬件）
	从内核栈恢复寄存器
	转到用户模式
	跳到main
	    ｜
	    v
	（main 程序）
	运行main
	调用系统调用
	陷入操作系统
	    ｜
	    V
	（硬件）
	将寄存器存到内核栈
	转向内核模式
	跳转到陷阱处理程序
	    ｜
	    v
	（内核模式）
	处理陷阱
	做系统调用工作
	从陷阱返回
	    ｜
	    v
	（硬件）
	从内核栈恢复寄存器
	转向用户模式
	跳到陷阱之后的计数器PC
	    ｜
	    v
	（程序）
	。。。
	从main返回return
	通过exit（）
	    ｜
	    v
	（内核模式）
	释放进程内存
	将进程是进程列表移除
6.3
进程之间切换

协作cooperative方式：等待系统调用
	在进程合理运行下，运行时间长的进程会主动放弃cpu控制权
	yield 系统调用-将控制权交给操作系统
	如果应用程序做了非法行为，也会控制转移给操作系统

非协作 操作系统进行控制
	时钟中断 timer interrupt-时钟设备可以设为每毫秒中断一次，产生中断，当前运行的程序会停止
	操作系统的interrupt handle 程序会运行
	操作系统会获得cpu控制权-停止或启动进程

	启动时，操作系统会通知硬件那些代码在发生时间中断
	启动过程中，操作系统必须启动时钟-特权操作

	硬件发生中断时，要为正在运行的程序保存足够的状态，为了能从trap from return 指令恢复正在运行的程序
	各个寄存器会进入内核栈

保存，恢复上下文
	当获得了CPU控制权，就必须决定时继续运行当前程序还是，还是切换到另一个进程-（程序调度 scheduler）
	
	上下文切换context switch
		为当前正在运行的进程保存寄存器的值（到它的内核栈）
		为即将要运行的进程（从内核栈）恢复一些寄存器的值

		操作系统会执行底层的汇编代码来保存当前正在运行进程的上下文
		会保存register PC 当前正在运行进程的内核栈指针
		会恢复register PC 然后切换内核栈 

受限直接执行协议 时钟中断
	启动系统
		初始化陷阱列表（内核模式）-> 记住 系统调用处理程序和时间处理程序的地址（硬件）-> 启动中断时钟（内核模式）-> 启动时钟 每隔多少ms中断CPU

	运行时
		运行进程A（程序）
		    ｜
		    v
		时钟中断（硬件）
		将寄存器保存到内核栈
		转向内核模式
		跳入陷阱处理程序
		     ｜
		     v
		处理陷阱（内核模式）
		调用switch（）（上下文切换）
		  将寄存器A保存到进程结构A
		  将进程结构B恢复到寄存器B
		从陷阱返回
		     ｜
		     v
		从内核栈B恢复到寄存器B（硬件）
		转成用户模式
		调到B的程序计数器PC
		     ｜
		     v
		运行进程B（程序）
		
问题：
  在系统调用期间发生时钟中断
  处理中断时发生另一个中断
解决：
  在中断处理时用禁止中断 disable interrupt -处理一个中断时，不会讲其他中断交给cpu
  
  加锁 locking-用于多处理器
		 	


