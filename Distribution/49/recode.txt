49.0
Andrew 文件系统
	扩展scale

49.1
AFS v1
	原来叫ITC分布式文件系统
	后来重新设计和最终协议

基本原则
	在访问客户端的本地磁盘local disk时，进行文件缓存whole-file cacheing
		当open（）文件时
		将从服务器读取整个文件
		并存储在本地磁盘文件中
		后续应用程序的read write操作会定向到本地文件系统（不用网络通信）
		close文件时
		文件会写回服务器
		（NFS是缓存块而不是整个文件，并缓存在客户端内存中而不是磁盘）

		当客户端调用open时
		AFS客户端向服务器发送fetch协议请求
		fetch协议将整个文件路径发送给服务器
		服务器将整个文件发送给客户端
		客户端将文件缓存在磁盘上
		AFS用客户端内存缓存块副本
		完成后检查文件是否已被修改
		如果被修改用store协议将新协议写回服务器

49.2
AFS v1两个主要问题

路径查找成本过高
	客户端将整个路径名发给服务器
	由于客户端同时访问服务器服务器花费大量cpu时间

客户端发出太多testauto协议消息（跟getattr相似）
	用该协议消息生成大量流量
	服务器花费大量时间告诉客户端时候可使用文件的缓存副本

解决：
	设计可扩展协议

49.4
AFS v2

回调callback
	当客户端缓存的文件被修改时
	服务器将通知客户端
	（客户端不需要在联系服务器）

文件标识符file identifier。FID（类似于NFS的文件句柄）
	不是让整个路径名发送给服务器，让服务器找
	而是让客户端沿着路径查找，每次一个，缓存结果

	列：
		客户端访问/foo/bar/foo。txt
		客户端先获取foo内容
		将他们放在本地磁盘缓存中
		参考书445页

49.5
缓存一致性

不同机器上的进程一致性
	当新文件刷新到服务器时
	服务器会中断拥有缓存副本的客户端的回调
	确保不再读取过时副本
	之后客户端需要让服务器重新获取文件新版本

	有时不同机器会在同一时间修改文件
	用最后写入者胜出last writer win
	最后调用close就能更新文件


49.6
崩溃恢复

假设client1在本地磁盘上缓存了F
client2更新了f
此时c1正在重新启动
服务器无法给c1发送消息
c1会丢失这些数据

解决：
	在重启时
	c1将所有缓存内容设为可疑
	在访问时会向服务器询问

49.7
AFS与NFS比较
	
大文件顺序重新读取
	AFS比NFS块
	AFS用本地磁盘缓存
	NFS只缓存块

文件覆盖
	AFS客户端需要完整提取旧文件再覆盖
	NFS只覆盖块
	NFS块

在大型文件里访问一小部分块
	NFS快
	AFS要获取整个文件
	NFS基于块协议，执行IO与读取或写入大小成比例
	