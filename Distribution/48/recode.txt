48.0
分布式文件系统
	有许多客户端机器和文件系统
	服务器将数据存在它的磁盘上
	客户端用协议去请求数据


	允许客户端共享数据
	
	集中管理centralized administration-备份文件不需要众多客户端，只要一点服务机器

	安全security


48.1
基本
比文件系统有更多组件

客户端
	用客户端文件系统client-side file system访问目录
	系统调用（open，read，write，close，mkdir）
	
	系统提供对文件透明transparent访问

	用户发出read（）
	客户端文件系统向服务端文件系统发送消息
	服务器将从磁盘取出块
	发送消息，将请求数据返回客户端
	客户端将数据复制到用户的缓冲区中	
	之后如果客户端重复访问，就会命中，不会产生流量

48.3
NFSv2协议（简单快速的服务器回复）
	服务器关闭一分钟都会让客户感到不快

48.4
无状态协议stateless
	服务器不会追踪每个客户端发生的事情（不知道客户端在缓存哪些块）

	每个客户端操作必须包含完成请求
	

有状态协议stateful
	给定路径名
	服务器返回文件描述符
	以后进行相应的读写操作
	
	问题：
		如果在返回文件描述符以后
		服务器崩溃了
		在重启服务器之后
		文件描述符就没有了

	恢复协议recovery protocol
		客户端必须确保在内存保存足够信息
		以便告诉服务器它知道的位置
	问题2:
		当服务器打开文件时
		客户端必须用close来关闭文件
		如果客户端崩溃了
		服务器永远也收不到close

48.5
NFSv2

文件句柄file handle
	用于唯一的描述文件和目录

	3个组件
		卷标识符-通知服务器请求指向哪个文件系统
		世代号-复用inode号时递增它
		inode号-告诉服务器请求访问该分区的那个文件
协议
	lookup获取文件句柄（/）
	如果客户端运行应用程序打开/foo。txt
	会向服务器发出查找请求
	向服务器传递文件句柄和名称
	如果成功，返回foo。txt的句柄（/foo。txt）
	
	客户端向系统发出read write


48.6
如果要访问/foo/bar/foo。txt
需要让客户端发送3次lookup
	一次在/找foo
	一次在/foo找bar
	一次在/foo/bar找txt文件

48.7
当客户端向服务器发送消息时有时候不会收到回复

处理故障（客户端）：
	重试请求
		
	在发送请求之后
	客户端将计时器设置为在指定时间之后关闭
	如果在关闭之前收到回复
	取消定时器

	幂等的idempotent
		操作执行多次和效果与执行一次的效果相同
		如果储存3次和储存一次效果一样
		那将值存到内存中时幂等的

		lookup和read是幂等的
		重复写入没有关系

48.8
改善分布式文件系统性能
	客户端缓存caching
	第一次访问是昂贵的
	之后几次就会块（在缓存里）

	可以用作写入零时缓冲区
	将应用程序的write延迟与实际写入分离
	程序对write调用会立即成功

48.9
缓存一致性问题
	假设有两个客户端c1，c2
	c1向服务端发送write
	但数据会先放在缓存里而不是直接写入
	这时c2向服务器发送read
	读到的还是旧数据
更新可见性：
	来自一个客户端的更新，如果被其他客户端发现

陈旧的缓存stale cache：
	在c1覆盖数据前
	c3先读取了数据
	那在c3里缓存的数据是旧数据

解决更新可见性-关闭时刷新flush-on-close：
	当应用程序写入文件并关闭时
	客户端将所有更新刷新到服务器

解决陈旧的缓存stale cache：
	客户端会先检查文件是否已更改
	再使用缓存的内容

	在打开文件时
	客户端系统会发出getattr获取文件属性
	属性包含服务器上次修改文件的信息
	如果修改时间比读取时间晚
	客户端会让文件无效invalidate
	将它从缓存中移除

	但让客户端一直发送getattr也不好

	属性缓存attribute cache
		首次访问文件时
		文件的属性会放在缓存中
		在一定时间后超时

48.11
假设就数据为
a
b
c
新数据是
x
y
z
客户端向服务器发送一个write请求
服务器接收此消息并发送到磁盘
向客户端发送成功

客户端发送第二个write请求
这次服务器把信息放在缓冲中并返回成功
但在写之前服务器崩溃了

重启后服务器接收第三个write请求并返回成功
之后内容如下
x
b
z

解决：
	每次会提交到稳定（持久）储存
	