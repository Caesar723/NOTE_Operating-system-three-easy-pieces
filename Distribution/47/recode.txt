47.0
分布式系统

当web连接其他地方的web服务器时-简单的client server 分布式系统

google 不只是一台机器进行交互
	是用大量机器来提供的
	每台机器提供站点的特定服务

故障failure
	机器，磁盘，软件都会故障
	通过大量机器来开起来很少失败

性能performance
	人员必须仔细考虑如何完成任务
	减少发送信息的数量

安全security
	当连接到远程方时
	确保远程方是他们声称的那些人

47.1
通信communication

通信基本是不可靠的（丢失，损坏，无法到达）
	在电气或其他问题时-位会被反转
	网络交换机，路由器，终端缺少缓冲-数据包丢失
		如果许多数据包同时到达
		路由器内存是无法容纳所有数据包的
		会选择丢弃drop


47.2
几乎所有的现代系统中，都有UDP/IP网络栈

UDP
	使用套接字（socket）API-创建通信端点communication endpoint
	其他机器的进程将UDP数据报datagram发送到前面的进程
	使用它会数据包丢失
	但包含checksum，检验包是否损坏

47.3
可靠的通信层

发送方如何知道接收放实际收到了消息

确认acknowledge
	发送方向接收方发信息
	接收方发短消息确认收到

超时timeout
	当发送方发送消息时
	会在一定时间关闭

	如果在此期间没有收到消息
	会重试retry
	（发送方要保留消息副本）

	问题：
		如果接收方会消息了但发送方没收到
		接收方可能会返回两次

只接收一次exactly one
	发送方为每个消息设置一个ID
	成本高

顺序计数器sequence counter
	发送方和接收方每一方会维护一个计算器
	使其值为一致
	设计数器值为1
	发送消息后变成2
	接收方（1）会受到这个值（1）
	相等接收方变成2
	如果又收到计数为1的会拒绝

47.4
通信抽象

分布式共享内存Distributed shared memory （DSM）
	使不同机器上的进程可以共享一个大的虚拟地址空间

	在计算机访问时有两种情况
		1.页面已经是机器上的本地页面
		2.页面在其他机器上
	最大问题-处理故障
		所有机器为一个地址空间
		如果有一部分数据结构不可用了
		如果下一个指针指向消失的空间
		那很难找到是哪个机器的
	性能不佳
	几乎没人用	
	

47.5
远程过程调用remote procedure call（RPC）
	使在远程机器上执行代码像调用本地函数一样简单直接

	进行一个过程调用，在一段时间后返回结果
	
	两部分：
		1.存根生成器stub generator
			通过自动化
			消除参数和结果的打包

			当用代码调用函数时：
				创建缓冲区-某种大小的连续字节数组
				将所有消息打包到消息缓冲区中-包含要调用的函数的标识符，参数
				将消息发送到RPC服务器
				等待回复
				解包 返回代码 参数
				返回调用者

				（服务器）
				解包消息
				调用实际函数
				打包结果-返回参数，放入回复缓冲区
				发送回复
				

		2.运行时库run-time library
			处理性能和可靠性问题
			
			如何找到远程服务
				客户端必须知道运行所需RPC服务器的主机名和IP地址和端口号
				用域名
				一旦客户端知道与哪个服务器通信
				获得特定远程服务
			构建RPC的传输协议
				是用TCP/IP-可靠协议
					会导致性能低效率
					要发送两个额外消息（确认相应，确认接收）
				还是用UDP/IP-不可靠通信层
					更高效
		
			
				