36.1
系统架构
	CPU用memory bus 连接到内存
	一些高性能IO设备（显卡）通过常规IO bus链接到系统
	外围总线peripheral bus如USB它们将最慢的设备连接到系统（磁盘，鼠标）
越快的总线越短
让高性能设备离CPU近一点
低性能离CPU远一点

36.2
标准设备
包含两个部分重要组件：
	1.向系统其他部分展现硬件接口interface
	2.内部结构internal structure
		复杂的会包含CPU，memory，和特定芯片
36.3
一个简化设备接口包含3个寄存器：
	状态status寄存器
		读取查看设备当前状态
	命令command寄存器
		通知设备执行某具体任务
	数据data寄存器
		将数据传输给设备或从设备接收数据

标准协议
	1.操作系统会反复读取状态寄存器，直到变为就绪状态（polling 设备-问它在做什么）
	2.操作系统下发数据到寄存器
		将磁盘块传递给设备
		如果CPU参与数据移动
		称为programed IO
	3.将命令写入命令寄存器
		这样设备就知道已经准备好了
		开始执行
	4.polling 设备， 判断是否完成任务


36.4
利用中断interrupt减少CPU开销
	向设备发出请求
	让其对应进程休眠
	切换执行其他任务
	当完成了以上操作，会抛出硬件中断
	先定义好中断服务例程interrupt service routine（ISR）
		一小段系统代码
		求结束之前进程的请求
		并唤醒等待IO的进程继续执行

36.5
中断允许用IO的时候重叠overlap
	如果不用中断	
	进程在IO的过程中只会自旋spin
	用了interrupt
	可以在用IO的时候让其他进程获得CPU控制权

中断不是总是好的
	如果一个设备性能很高，处理快
	CPU一次轮询就可以返回结果
	用中断反而会让系统变慢
	解决：
		可以用混合策略hybrid
		先轮询polling一段时间
		再interrupt

在网络时最好不要用中断：
	网路接收大量数据包
	如果每接收一个数据包用一次中断
	那可能导致系统发生livelock-无法处理用户层请求
	解决：
		用合并coalescing
		在中断抛出之前等待一小段时间
		在此期间，其他请求可能很快完成
		多次中断就可以合为一次中断


36.5
在用磁盘IO时
会先把数据拷贝到磁盘
这段时间会浪费时间和算力
 
使用DMA direct memory access	
	操作系统会通过编程告诉DMA“引擎数据在内存的位置，要拷贝的大小，要拷贝到哪个设备”
	这样操作系统就可以处理其他请求了

36.6
硬件如何与设备通信

方式1
	用明确的IO指令
	当需要发生数据给设备时
	调用者指定一个存入数据的特定寄存器和一个代表设备的特定端口-特权指令privileged
	操作系统是唯一一个可以与设备交互的实体
方法2:
	用内存映射IO memory mapped IO
	硬件将设备寄存器作为内存地址memory address提供
	当访问设备寄存器时
	操作系统会（读取或写入）到内存地址
	硬件将把读取或写入到内存地址的数据转移到设备上，而不是物理内存


36.7
每个设备都有非常具体的接口，如何将它们纳入操作系统

用抽象abstraction技术	
	在最底层，操作系统一部分软件知道设备如何工作（驱动程序device driver）

36.8
与设备交互简单协议
	等待驱动就绪-读取状态寄存器，直到驱动Ready而非忙碌
	向命令寄存器写入参数-如写入扇区数，逻辑块地址LBA，驱动编号
	开启IO-发送读写命令到命令寄存器
	数据传送（针对写请求）-等待状态为ready和DRQ（驱动请求数据），向数据端口写入数据
	中断处理-在传送结束后出发中断处理程序
	错误处理-在结束后检查状态寄存器，如果error，可以读取错误寄存器来或取信息