42.0
主要挑战
	在崩溃和断电情况下怎么更新持久数据结构
	在更新数据结构过程中，突然没电了怎么办？

崩溃一致性问题crash- consistency problem
	有两个磁盘
	磁盘一次只为一个请求服务
	当更新完一个磁盘时，没电了
	就会不一致inconsistent

42.1
假如有一个文件
其inode里面是
	size：1
	owner
	pointer：4
	pointer：null
	pointer：null

	当更新追加一些数据时
	会增加一个块
	inode 变成了

	size：2
	owner
	pointer：4
	pointer：5
	pointer：null

	更新的有
		数据块
		inode
		数据位块


崩溃的场景、
	只有数据块写入
		没有指向，跟没写一样
	只有inode写入
		会信任一个指针，但指向的是垃圾数据

	只有数据位图更新
		已经分配了
		没有inode指向它
		空间泄露space leak

	等等。。。

42.2

文件系统检查程序

fsck
	在文件系统挂载或可用之前运行
	
	超级块
		检查超级块是否合理	
		确保文件系统大小大于分配块数
		
	空闲块
		fsck扫描inode，间接块，双重间接块
		生成正确版本的分配位图
	inode状态
		检查每个inode是否损坏
		如果存在问题，不易修复，会被清除
	inode链接
		验证被分配的inode的链接数
		
	重复
		fsck检查重复指针
		如果指针指向超出有效范围的某个指针
		会被认为是坏的
	目录检查
		确保'.'   '..'是前面的目录
		确保目录条目的每个inode都被分配

	问题：
		太慢了
		可能要几个小时来扫描


预写日志write ahead logging
	在更新结构之前
	会写下一些信息-描述将要做的事情

	在崩溃发生时
	可以查看最新日志
	用来重新使用日志里的内容

数据日志data journaling
	包含
	（逻辑日志logical logging）-提高效率
		开头：TxB
		结尾：TxE
		事务标识符transection identifier TID
	（物理日志physical logging）-确切的物理内容
		一块inode的最终选址
		一块位图的最终选址
		一块数据块的最终选址

	操作流程
		将那些logical logging 和 physical logging	写入日志
		将physical logging所对应的信息写入磁盘（加检查点 checkpointing）
	如果在写入日志时发生崩溃会很糟
	解决：
		在写完日志时写上TxE
		确保安全
		此过程为原子性
	最终操作流程
		日志写入：写入物理日志
		日志提交：加上TxE
		加检查点：把原数据写入磁盘

利用日志恢复recover
	如果已经提交日志，在检查点发生崩溃（redo logging重做日志）
		文件系统会扫描日志
		找到已经提交到磁盘的磁盘事物
		这些事务会被replayed，重新做一次
使日志有限
	如果不断添加事务
	会被很快填满
	问题：
		日志越大
		恢复时间越长
		无法像磁盘提交事务

	文件系统将日志视为循环数据结构
	一遍一遍重复使用
	
	日志超级块
		标记日志最旧最新的事物
	
	在最后一个步骤加一个步骤
		释放：通过更新日志超级块，把一些事物标记为空闲，去减少恢复时间

最终日志协议
	日志写入：写入物理日志
	日志提交：加上TxE
	加检查点：把原数据写入磁盘
	释放：通过更新日志超级块，把一些事物标记为空闲，去减少恢复时间


元数据日志metadata logging 有序日志ordered logging
	提高性能
	消除了用户数据
	先将用户数据块写入磁盘
	再做以下操作
		日志元数据写入：写入inode和位图
		日志提交：加上TxE
		加检查点：把原数据写入磁盘
		释放：通过更新日志超级块，把一些事物标记为空闲，去减少恢复时间

块复用
	如果有一个目录foo
	它加了一个条目然后删除了foo
	这些会被记录在日志里
	然后在删除的地方加了一个foobar块
	
	这时发生了故障
	所有信息被重放
	这时foo的内容会覆盖foobar

	解决方案
		1.永远不再使用这些块
		直到该日志被删除

		2.把新纪录添加到 撤销revoke纪录
		删除目录会将撤销纪录里的东西写入日志
		在重放日志时
		会扫描撤销纪录
		被撤销的纪录不会被重放

42.4
反向指针一致性backpointer-based consistency
	每个块都会有一个反向指针
	如数据块会有一个额外指针指向inode
	可以相互检查
